============================================
vis/sakpals.OUT
22:59:21_Wednesday_24_May_2017
============================================
=== COMP30023 Project 2 Feedback ===
 
total 68K
drwxr-x---. 4 ss ldaemon 4.0K May 24 22:58 .
drwxr-x---. 4 ss ldaemon 4.0K May 24 22:58 ..
-rwx------. 1 ss ldaemon  583 May 24 22:58 Makefile
drwxr-x---. 2 ss ldaemon 4.0K May 24 22:58 invis
-rwx------. 1 ss ldaemon  17K May 24 22:58 protocol_messages.c
-rwx------. 1 ss ldaemon 1.3K May 24 22:58 protocol_messages.h
-rwx------. 1 ss ldaemon 7.3K May 24 22:58 server.c
-rwx------. 1 ss ldaemon 5.6K May 24 22:58 sha256.c
-rwx------. 1 ss ldaemon 1.3K May 24 22:58 sha256.h
-rwx------. 1 ss ldaemon 2.9K May 24 22:58 uint256.h
drwx------. 2 ss ldaemon 4.0K May 24 22:58 vis
================ START RUN SCRIPT ================
Current Working Directory: /home/ss/subrun-4000v-cis-nutmeg-l-18426/comp30023_project2/sakpals
Submitted Files: total 60
-rwx------. 1 ss ldaemon   583 May 24 22:58 Makefile
drwxr-x---. 2 ss ldaemon  4096 May 24 22:58 invis
-rwx------. 1 ss ldaemon 16414 May 24 22:58 protocol_messages.c
-rwx------. 1 ss ldaemon  1305 May 24 22:58 protocol_messages.h
-rwx------. 1 ss ldaemon  7474 May 24 22:58 server.c
-rwx------. 1 ss ldaemon  5708 May 24 22:58 sha256.c
-rwx------. 1 ss ldaemon  1306 May 24 22:58 sha256.h
-rwx------. 1 ss ldaemon  2897 May 24 22:58 uint256.h
drwx------. 2 ss ldaemon  4096 May 24 22:58 vis
gcc -Wall -g -Wextra  -std=gnu99   -c -o protocol_messages.o protocol_messages.c
gcc -Wall -g -Wextra  -std=gnu99   -c -o sha256.o sha256.c
gcc -Wall -g -Wextra  -std=gnu99   -c -o server.o server.c
gcc -Wall -g -Wextra  -std=gnu99 -o server protocol_messages.c sha256.c server.c  -pthread
F.......EEE....EEEE.......
======================================================================
ERROR: test_multi_work2 (__main__.TestMultiWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 324, in test_multi_work2
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_multi_work3 (__main__.TestMultiWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 333, in test_multi_work3
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_multi_work4 (__main__.TestMultiWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 342, in test_multi_work4
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_solo_work1 (__main__.TestSingleWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 257, in test_solo_work1
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_solo_work2 (__main__.TestSingleWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 266, in test_solo_work2
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_solo_work3 (__main__.TestSingleWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 275, in test_solo_work3
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
ERROR: test_solo_work4 (__main__.TestSingleWorkCorrectness)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 284, in test_solo_work4
    ret = s.recv(1024)
  File "../data/test.py", line 23, in _handle_timeout
    raise TimeoutError(error_message)
TimeoutError: Timer expired

======================================================================
FAIL: test_ping (__main__.TestBasicPingPong)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "../data/test.py", line 29, in wrapper
    result = func(*args, **kwargs)
  File "../data/test.py", line 76, in test_ping
    self.assertEqual(ret, b'PONG\r\n')
AssertionError: 'x\xe1\xb8 6P' != 'PONG\r\n'

----------------------------------------------------------------------
Ran 26 tests in 60.211s

FAILED (failures=1, errors=7)
================ END RUN SCRIPT ================
================ START STDOUT ==================
ERROR reading from socket: Connection reset by peer
================ END STDOUT ====================
 
=== COMP30023 Project 2 Feedback END ===
============================================
src/uint256.h
22:57:27_Wednesday_24_May_2017
============================================
#ifndef UINT256_H
#define UINT256_H
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

#ifndef BYTE_H
#define BYTE_H
typedef unsigned char BYTE;
#endif


static inline void uint256_init (BYTE *uint256) {
    if (uint256 == NULL) {
        return;
    }
    for (size_t i = 0; i < 32; uint256[i++] = 0);
}

static inline void print_uint256 (BYTE *uint256) {
    printf ("0x");
    for (size_t i = 0; i < 32; i++) {
        printf ("%02x", uint256[i]); 
    }
    printf ("\n");
}

static inline void uint256_sl (BYTE *res, BYTE *a, BYTE shift) {
    if (res == NULL || a == NULL) {
        return;
    }
    BYTE b = shift / 8;
    BYTE move_n = shift % 8;
    BYTE mask = 0;
    BYTE carry = 0;
    if (shift == 0) {
        memcpy (res, a, 32); 
        return;
    }
    mask = 0xff << (8 - move_n);
    for (int i = 31 - b, j = 31; i > -1; i--, j--) {
        res[i] = (a[j] << move_n) | carry; 
        carry = (a[j] & mask) >> move_n;
    }
}

static inline void uint256_add (BYTE *res, BYTE *a, BYTE *b) {
    if (res == NULL || a == NULL || b == NULL) {
        return;
    }
    BYTE aa[32], bb[32];
    uint256_init (aa);
    uint256_init (bb);

    memcpy (aa, a, 32);
    memcpy (bb, b, 32);
    uint16_t temp = 0;
    for (size_t i = 0; i < 32; i++) {
        temp >>= 8;
        temp += aa[i] + bb[i];
        res[i] = (BYTE) (temp & 0xff); 
    }
}

static inline void uint256_mul (BYTE *res, BYTE *a, BYTE *b) {
    if (res == NULL || a == NULL || b == NULL) {
        return;
    }
    
    BYTE temp[32], acc[32], aa[32], bb[32]; 
    // we want to assert the invariance of a, b in the event that
    // a == res || b == res
    uint256_init (temp);
    uint256_init (aa);
    uint256_init (bb);
    uint256_init (acc);
 
    memcpy (bb, b, 32);
    memcpy (aa, a, 32);
   
    for (int i = 255; i > -1; i--) {
        if ((bb[i/8] & (1 << (7 - (i % 8)))) > 0) {
            uint256_sl (temp, aa, 255 - i);
            uint256_add (acc, acc, temp);
        }
    }
    memcpy (res, acc, 32);
}

// we bound the exponent to 4 bytes as it is pointless to support an
// integer greater than that, it'd simply overflow beyond 256bits.
static inline void uint256_exp (BYTE *res, BYTE *base, uint32_t exp) {
    if (res == NULL) {
        return;
    }
    if (exp == 0) {
        for (size_t i = 0; i < 31; res[i++] = 0);
        res[31] = 0x1;
        return;
    }

    BYTE temp[32], acc[32];
    uint256_init (temp);
    uint256_init (acc);

    if (res != base) {
        memcpy (acc, base, 32);
    }
   
    temp[31] = 0x1;

    while (exp > 1) {
        if (exp % 2 == 0) {
            uint256_mul (acc, acc, acc);
            exp = exp / 2;
            
        } else {
            uint256_mul (temp, acc, temp);
            uint256_mul (acc, acc, acc);
            exp = (exp - 1) / 2;
        }
    }
    uint256_mul (res, acc, temp);
}

#endif============================================
src/sha256.h
22:57:27_Wednesday_24_May_2017
============================================
/*********************************************************************
* Filename:   sha256.h
* Author:     Brad Conte (brad AT bradconte.com)
* Copyright:
* Disclaimer: This code is presented "as is" without any guarantees.
* Details:    Defines the API for the corresponding SHA1 implementation.
*********************************************************************/

#ifndef SHA256_H
#define SHA256_H

/*************************** HEADER FILES ***************************/
#include <stddef.h>

/****************************** MACROS ******************************/
#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 byte digest

/**************************** DATA TYPES ****************************/
#ifndef BYTE_H
#define BYTE_H
typedef unsigned char BYTE;             // 8-bit byte
#endif

typedef unsigned int  WORD;             // 32-bit word, change to "long" for 16-bit machines

typedef struct {
	BYTE data[64];
	WORD datalen;
	unsigned long long bitlen;
	WORD state[8];
} SHA256_CTX;

/*********************** FUNCTION DECLARATIONS **********************/
void sha256_init(SHA256_CTX *ctx);
void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len);
void sha256_final(SHA256_CTX *ctx, BYTE hash[]);
int sha256_compare(BYTE digest1[], BYTE digest2[]); 

#endif   // SHA256_H
============================================
src/protocol_messages.c
22:57:27_Wednesday_24_May_2017
============================================
#include "protocol_messages.h"


char *read_message(char *msg, work_msg_t **worker_queue, int i){

	BYTE header[HEADER_LEN + 1];
	int size  = 100;
	unsigned long payload_length;

	
	char *return_msg = (char *)malloc(sizeof(char)*size);
	return_msg = create_response_msg(return_msg, "", &size);
	
	char *token = strtok(msg, "\r");
	while(token!= NULL) {

		header[4] = '\0';
		strncpy((char *)&header, msg,4);
		
		if(strcmp((const char *)&header, "PING") == 0) {
			payload_length = 0;	
			if((strlen(msg)-(HEADER_LEN)) != payload_length) {
				return_msg = create_response_msg(return_msg, "ERRO bad message!\r\n", &size);		
			} 
			else {
				return_msg = create_response_msg(return_msg, "PONG\r\n", &size);
			}	
		}
		else if(strcmp((const char *)&header, "PONG") == 0) {
			payload_length = 0;
			if((strlen(msg)-(HEADER_LEN)) != payload_length) {
				return_msg=create_response_msg(return_msg, "ERRO bad message!\r\n", &size);
				
			} 
			else {
				return_msg=create_response_msg(return_msg, "ERRO PONG message is strictly reserved for server responses!\r\n", &size);
			}
		}
		else if(strcmp((const char *)&header, "OKAY") == 0) {
			payload_length = 0;
			if((strlen(msg)-(HEADER_LEN)) != payload_length) {
				return_msg = create_response_msg(return_msg, "ERRO bad message!""ERRO bad message!\r\n", &size);
			} 
			else {
				return_msg = create_response_msg(return_msg, "ERRO it's not okay to send OKAY messages to server!\r\n", &size);
			}
		}
		else if(strcmp((const char *)&header, "ERRO") == 0) {
			payload_length = 40;
			// +1 for the space after ERRO
			if((strlen(msg)-(HEADER_LEN+1)) != payload_length) {
				return_msg =create_response_msg(return_msg, "ERRO bad message!\r\n", &size);
			} 
			else {
				return_msg = create_response_msg(return_msg, "ERRO you should not send 'ERRO' messages to server!\r\n", &size);
			}
		}
		else if(strcmp((const char *)&header, "SOLN") == 0) {
			payload_length = 90;
			// +1 for the space after SOLN 
			if((strlen(msg)-(HEADER_LEN+1)) != payload_length) {
				return_msg =create_response_msg(return_msg, "ERRO bad message!\r\n", &size);
				
			} 
			// return_msg should be OKAY if its a valid proof of work
			else if(process_solution(msg) == 1) {
				return_msg = create_response_msg(return_msg, "OKAY\r\n", &size);
			}
			//otherwise reply with ERRO  with a 40-byte string describing error
			else {
				return_msg = create_response_msg(return_msg, "ERRO not a valid proof of work!              \r\n", &size);
			}
		}
		else if(strcmp((const char *)&header, "WORK") == 0) {
			payload_length = 93;
			// + 1 for the space after WORK
			if((strlen(msg) -(HEADER_LEN+1)) != payload_length) {
				return_msg =create_response_msg(return_msg, "ERRO bad message!\r\n", &size);
			}
			else {
				parse_work(worker_queue, msg, i);

				/* ******* */
				int len = 0;
				work_msg_t *tmp = *worker_queue;
				while(tmp != NULL) {
					len ++;
					tmp = tmp->next;
				}
				printf("worker_queue size = %d\n", len);
				/* ******* */
			}	
			//NOTE: actual work() message is being handled in the server program
		}
		else if(strcmp((const char *)&header, "ABRT") == 0) {
			payload_length = 0;
			if((strlen(msg) - HEADER_LEN) != payload_length) {
				return_msg = create_response_msg(return_msg, "ERRO bad message!\r\n", &size);	
			}
			else {
				remove_work(worker_queue, i);

				/* ******* */
				int len = 0;
				work_msg_t *tmp = *worker_queue;
				while(tmp != NULL) {
					len ++;
					tmp = tmp->next;
				}
				printf("worker_queue size = %d\n", len);
				/* ******* */

				
				return_msg = create_response_msg(return_msg, "OKAY\r\n", &size);	
			}
		}
		else {
			return_msg =create_response_msg(return_msg, "ERRO server doesn't accept this message      \r\n", &size);
		}	
		token = strtok(NULL, "\r");

	}
	return return_msg;
}
// try to FREE THINGS!!
void remove_work(work_msg_t **worker_queue, int client_fd) {
	work_msg_t *tmp = *worker_queue;
	while(tmp != NULL) {
		// if its in the front of the queue
		if(*worker_queue == tmp && tmp->client_fd == client_fd) {
			*worker_queue = tmp->next; // free(tmp) ?
		}
		// if its the last or in the middle of the queue
		else if(tmp->next != NULL) {
			if(tmp->next->client_fd == client_fd) {
				// remove all pending work for this client 
				tmp->next = tmp->next->next; // free(tmp->next) ?
			}
		}
		tmp = tmp->next;
	}

}
// parses work msg and adds to queue
void parse_work(work_msg_t **worker_queue, char *msg, int client_fd) {
	BYTE *target;
	int i = 0;
	char *token = strtok(msg, " ");
	uint32_t difficulty;
	BYTE *seed;
	uint64_t start;
	uint8_t worker_count;

	char *str_difficulty = (char *)malloc(sizeof(char)*8);
	char *str_seed = (char *)malloc(sizeof(char)*64);

	while(token != NULL) {
		if(i == 1) {
			strcpy(str_difficulty, token);
			difficulty = strtoul(token, NULL, 16);
		}
		else if(i==2) {
			strcpy(str_seed, token);
			seed = get_seed(token);
		}
		else if(i==3) {
			start = strtoull(token, NULL, 16);
			
		}
		else if(i==4) {
			worker_count = (uint8_t)strtol(token, NULL, 16);
		}
		token = strtok(NULL, " ");
		i++;
	}
	target = map_difficulty(difficulty);

	work_msg_t *new_work = (work_msg_t *)malloc(sizeof(work_msg_t));
	new_work->difficulty = difficulty;
	new_work->seed = seed;
	new_work->start = start;
	new_work->worker_count = worker_count;
	new_work->target = target;
	new_work->client_fd = client_fd;
	new_work->str_difficulty = str_difficulty;
	new_work->str_seed = str_seed;
	new_work->next = NULL;


	// add this new work message to the end of the worker_queue
	work_msg_t *tmp = *worker_queue;
	if(tmp == NULL) {
		*worker_queue = new_work;
	}
	else {
		while( tmp->next != NULL) {
			tmp = tmp->next;
		}
		tmp->next = new_work;
	}
}


int process_work(work_msg_t *work) {
	SHA256_CTX ctx;
	BYTE *x;
	char *str_start =  (char *)malloc(sizeof(char)*16);
	BYTE buf[SHA256_BLOCK_SIZE];
    BYTE second_buf[SHA256_BLOCK_SIZE];
    x = concatenate(work->seed, work->start);

    str_start = convert_to_hex3(work->start);

	work->str_start = str_start;
	//printf("in process Work: work->str_start ----> %s\n", work->str_start);
    sha256_init(&ctx);
    sha256_update(&ctx, x, 40);
    sha256_final(&ctx, buf);

    sha256_init(&ctx);
    sha256_update(&ctx, buf, 32);
    sha256_final(&ctx, second_buf);

   
    //free(str_start);
    return sha256_compare(work->target, second_buf);

}

int process_solution(char *msg) {
	char *token = strtok(msg, " ");
	int i=0,j=0;
	uint32_t difficulty;// = (uint32_t)strtol(hex, NULL, 16);
	BYTE *seed;
	uint64_t solution;
	BYTE *target;
    BYTE *x = (BYTE *)malloc(sizeof(BYTE)*40);
    SHA256_CTX ctx;
    //SHA256_CTX ctx2;
    BYTE buf[SHA256_BLOCK_SIZE];
    BYTE second_buf[SHA256_BLOCK_SIZE];

	// get the difficulty, seed and solution from the SOLN string
	while(token!= NULL) {
		if(i == 1) {
			difficulty = strtoul(token, NULL, 16);
			//printf("difficulty  = %u\n", difficulty);
		}
		else if(i==2) {
			seed = get_seed(token);

			//print_uint256(seed);
		}
		else if(i ==3){
           // printf("token = %s\n", token);
			solution = strtoull(token, NULL, 16);
			//printf("solution =  %" PRIu64 "\n", solution);
		}
		//printf("token = %s\n", token);
		token = strtok(NULL, " ");
		i++;
	}
    //printf("target = ");
	target = map_difficulty(difficulty);
   // print_uint256(target);
    //printf("\n");

    BYTE *hex_sol = get_solution(solution);
    for(i=0; i < 40; i++) {
        x[i] = 0;
    }

    for(i=0; i < 32; i++) {
        x[i] = seed[i];
    }
    for(i=32; i < 40; i++){
        x[i] = hex_sol[j];
        j++;
    }
  
    //x = concatenate(seed, solution);
   // printf("concat = ");
    //print_uint256(x);
   // printf("\n");

    sha256_init(&ctx);
    sha256_update(&ctx, x, 40);
    sha256_final(&ctx, buf);

    sha256_init(&ctx);
    sha256_update(&ctx, buf, 32);
    sha256_final(&ctx, second_buf);
/*
    printf("printing buffer for hash(x) \n");
    for(i = 0; i < SHA256_BLOCK_SIZE; i++) {
        printf("%02x", buf[i]);
    }
    printf("\n");

    printf("printing buffer for hash(hash(x)) \n");
    for(i = 0; i < SHA256_BLOCK_SIZE; i++) {
        printf("%02x", second_buf[i]);
    }
    printf("\n");

	*/
	//printf("sha256_compare(target, second_buf) = %d\n", sha256_compare(target, second_buf));
	return sha256_compare(target, second_buf);
   // printf("sha256_compare = %d\n", sha256_compare(target, second_buf));
// need to free all the malloc'd variables!!!!

}

BYTE *concatenate(BYTE *seed, uint64_t solution) {
    int i,j=0;
    BYTE *hex_sol = get_solution(solution);
    BYTE *con = (BYTE *)malloc(sizeof(BYTE)*40);

    //initialise con
    for(i=0; i < 40; i++) {
        con[i] = 0;
    }

    for(i=0; i < 32; i++) {
        con[i] = seed[i];
    }
    for(i=32; i < 40; i++){
        con[i] = hex_sol[j];
        j++;
    }
    
   /* printf("printing con...\n");
    for(i = 0; i < 40; i++) {
        printf("%02x", con[i]);
    }
    printf("\n");*/
    return con;
}

BYTE *get_solution(uint64_t solution) {
   	//uint64_t solution = ntohl(get_solution);
  //  printf("solution = %llu\n", solution);
    char remainders[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
    int i = 7;
    BYTE rem_index;
    uint64_t quotient = solution;
    //printf("quotient = %llu\n",quotient);
    int num1;
    int num2;
    int num3;
    BYTE *hex_num = (BYTE *)malloc(sizeof(BYTE)*8);

  //  printf("in get_solution ===\n");
    while(quotient != 0 && i >= 0) {
        rem_index = quotient%16;
        num1 = remainders[rem_index];
        quotient /= 16;
         //printf("rem_index = %d quotient = %llu\n",rem_index, quotient);
        if(quotient != 0 && i >= 0) {
            rem_index = quotient%16;
            num2 = remainders[rem_index];
            quotient /= 16;
            //printf("num2 << 4 = %2d\n", num2);
            num3 = (num2<<4)|num1;
            //printf("%d", num3);
           // printf("i = %d, num1 = %x, num2 = %x, num3 = %x\n", i,num1, num2, num3);
            hex_num[i] = num3;

        }
        else {
            i--;
            break;
        }
        i--;
    }
    while(i>=0) {
        hex_num[i] = 0x00;
        i--;
    }
    /*
    printf("printing hex_sol for %" PRIu64 "\n", solution);
    for(i=0; i<8; i++) {
        printf("%02x", hex_num[i]);
    }
    printf("\n");*/
    return hex_num;
}

BYTE *get_seed(char *token) {
	int i, k = 31;
	int num1, num2, num3;
	char s[2];
	BYTE *seed = (BYTE *)malloc(sizeof(BYTE)*32);
	char remainders[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
	char raw_seed[64+1];
	//raw_seed[64] = '\0';
	for(i = 64; i >= 1; i-= 2) {
		strncpy(raw_seed, token, i);
		//raw_seed[i] = '\0';
		s[1] = '\0';
		s[0] = raw_seed[i-1];
		//s = raw_seed[i-1];
		//printf("s = %s  ", s);

		num1 = remainders[strtol(s, NULL, 16)];
		//printf("strtol(&s, NULL, 16) = %ld\n", strtol(s, NULL, 16));

		//raw_seed[i-1] = '\0';
		s[1] = '\0';
		s[0] = raw_seed[i-2];
		//s = raw_seed[i-2];
		//printf("s = %s  ", s);
		num2 = remainders[strtol(s, NULL, 16)];


		num3 = (num2<<4)|num1;
	
		//printf("strtol(&s, NULL, 16) = %ld\n", strtol(s, NULL, 16));
		seed[k] = num3;
		
		k--;
		num1 = 0;
		num2 = 0;
		num3 = 0;

	}
	/*
	  for(i=0; i < 40; i++) {
        printf("seed[%d] = %d\n", i, seed[i]);
    }*/
	return seed;
}


// change return to BYTE *
BYTE *map_difficulty(uint32_t get_difficulty) {
    uint32_t difficulty = ntohl(get_difficulty);
	//uint32_t difficulty = get_difficulty;
	int i,j;
	BYTE *target = (BYTE *)malloc(sizeof(BYTE)*32);
	BYTE exp[32];
	BYTE two[32];

	uint256_init(target);
	uint256_init(exp);
	uint256_init(two);
	two[31] = 0x2;

	BYTE *binary_num = convert_to_binary(difficulty);

	BYTE *hex_beta;

	uint32_t alpha = 0;
	uint32_t beta = 0;
    j=7;
    // extract alpha assuming ordering is 01234... from array?? CHECK!
    for(i = 24; i <= 31; i ++) {

        if(binary_num[i] == 1) {
            alpha += two_power_of(j);
        
        }
        j--;
    }

    j= 23;
    // extract beta 
    for(i = 0; i <= 23; i++) {
        if(binary_num[i] == 1) {
            beta += two_power_of(j);
        }
        j--;
    }   
	// let alpha be the exponent 
	alpha = 8*(alpha-3);
	/*for(i=0; i<32; i++) {
		printf("%d", binary_num[i]);
	}
	printf("\n");
*/

	//printf("alpha = %d\n", alpha);
	//printf("beta = %d\n", beta);

	//printf("2^8*(alpha-3) is...\n");
	uint256_exp(exp, two, alpha);
	//print_uint256(exp);
	
	hex_beta = convert_to_hex2(beta);
	//printf("printing target ....\n");
	uint256_mul(target, hex_beta, exp);
	//print_uint256(target);
	return target;

}
uint32_t two_power_of(int num) {
	int i;
	uint32_t val  = 1;
	for(i = 1; i <= num; i++) {
		val *= 2;
	}
	return val;
}
char *convert_to_hex3(uint64_t num) {
	char numbers[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
	char remainders[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
	int i = 31, j = 15;
	BYTE rem_index;
	uint64_t quotient = num;
	int num1;
	int num2;
	int num3;
	char *str_start = (char *)malloc(sizeof(char)*16);

	BYTE *hex_num = (BYTE *)malloc(sizeof(BYTE)*32);
	while(quotient != 0 && i >= 0) {
		//printf("quotient = %llu\n", quotient);
		rem_index = quotient%16;

		num1 = remainders[rem_index];
		quotient /= 16;
		if(quotient != 0 && i >= 0) {
			rem_index = quotient%16;
			num2 = remainders[rem_index];
			quotient /= 16;

			num3 = (num2<<4)|num1;
			hex_num[i] = num3;
			if(j >= 0) {
				str_start[j] = numbers[num1];
				//printf("str_start[%d] = %c\n",j, str_start[j]);
				j --;
				str_start[j] = numbers[num2];
				//printf("str_start[%d] = %c\n",j, str_start[j]);
				j --;
			}

		}
		else {
			i--;
			break;
		}
		i--;
	}
	//printf("quotient = %llu\n", quotient);
	while(i>=0) {
		hex_num[i] = 0x00;
		if(j >= 0) {
			str_start[j] = numbers[0];
			//printf("str_start[%d] = %c\n",j, str_start[j]);
			j--;
		}
		i--;
	}
	
	//printf("printing hex for %" PRIu64 "\n", num);
	/*for(i=0; i<16; i++) {
		printf("%c",str_start[i]);
	}
	printf("\n");*/
	//printf("str_start = %s\n", str_start);
	return str_start;

}

BYTE *convert_to_hex2(uint32_t num) {
	char remainders[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
	int i = 31;
	BYTE rem_index;
	uint32_t quotient = num;
	int num1;
	int num2;
	int num3;
	BYTE *hex_num = (BYTE *)malloc(sizeof(BYTE)*32);
	while(quotient != 0 && i >= 0) {
		rem_index = quotient%16;
		num1 = remainders[rem_index];
		quotient /= 16;
		if(quotient != 0 && i >= 0) {
			rem_index = quotient%16;
			num2 = remainders[rem_index];
			quotient /= 16;

			num3 = (num2<<4)|num1;
			hex_num[i] = num3;

		}
		else {
			i--;
			break;
		}
		i--;
	}
	while(i>=0) {
		hex_num[i] = 0x00;
		i--;
	}
	/*
	printf("printing hex for %d\n", num);
	for(i=0; i<32; i++) {
		printf("%d", hex_num[i]);
	}
	printf("\n");*/
	return hex_num;

}

BYTE *convert_to_hex(BYTE *binary_num) {
	int i=31, j, k =31;
	
	char remainders[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
	int num1;
	int num2;
	int num3;

	BYTE *hex = (BYTE *)malloc(sizeof(BYTE)*32);
	int rem_index= 0;

	while(i >= 3) {
		for(j=i; j > i-4; j--) {
			if(binary_num[j] == 1) {
				rem_index += two_power_of(i-j);
			}

		}
		num1 = remainders[rem_index];
		i -=4;
		rem_index = 0;
		if(i >= 3) {
			for(j=i; j > i-4; j--) {
				if(binary_num[j] == 1) {
					rem_index += two_power_of(i-j);
				}

			}
			num2 = remainders[rem_index];
		}
		else {
			break;
		}
		num3 = (num2<<4)|num1;
		hex[k] = num3;
		k--;
		rem_index = 0;
		i-= 4;
	}
	

	return hex;
}


BYTE *convert_to_binary(uint32_t num) {
	int i = 31;
	BYTE remainder;
	uint32_t quotient = num;
	BYTE *binary_num = (BYTE *)malloc(sizeof(BYTE)*32);
	while(quotient != 0 && i >= 0) {
		remainder = quotient%2;
		quotient /= 2;
		
		binary_num[i] = remainder;
		
		i--;
	}
	while(i>=0) {
		binary_num[i] = 0;
		i--;
	}
    /*
	printf("printing binary for %d\n", num);
	for(i=0; i<32; i++) {
		printf("%d", binary_num[i]);
	}
	printf("\n");*/
	return binary_num;

}

char *create_response_msg(char *curr_msg, char *add, int *size) {
	if((int)(strlen(add)+strlen(curr_msg)) > *size) {
		*size = 2*(strlen(add)+strlen(curr_msg));
		curr_msg = realloc(curr_msg, *size);
		strcat(curr_msg,add);

	}
	else {
		strcat(curr_msg,add);
	}
	return curr_msg;
}

============================================
src/sha256.c
22:57:27_Wednesday_24_May_2017
============================================
/*********************************************************************
* Filename:   sha256.c
* Author:     Brad Conte (brad AT bradconte.com)
* Copyright:
* Disclaimer: This code is presented "as is" without any guarantees.
* Details:    Implementation of the SHA-256 hashing algorithm.
              SHA-256 is one of the three algorithms in the SHA2
              specification. The others, SHA-384 and SHA-512, are not
              offered in this implementation.
              Algorithm specification can be found here:
               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
              This implementation uses little endian byte order.
*********************************************************************/

/*************************** HEADER FILES ***************************/
#include <stdlib.h>
#include <memory.h>
#include "sha256.h"

/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

/**************************** VARIABLES *****************************/
static const WORD k[64] = {
	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

	for (i = 0, j = 0; i < 16; ++i, j += 4)
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}

void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}

void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
	WORD i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}

void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
	WORD i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
	}
}

// ====================================================
// compares two custom CHA256_CTX objects to see which is greater
// return values:
// -1, ctx1 < ctx2
// 0, equal
// 1, ctx1 > ctx2
int sha256_compare(BYTE digest1[], BYTE digest2[]) 
{
    for (size_t i = 0; i < 32; i++) {
        if (digest1[i] < digest2[i]) {
            return -1;
        } else if (digest1[i] > digest2[i]) {
            return 1;
        } 
    }
    return 0;
}
============================================
src/protocol_messages.h
22:57:27_Wednesday_24_May_2017
============================================
#ifndef PROTOCOL_MESSAGES_H_
#define PROTOCOL_MESSAGES_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <inttypes.h>
#include "uint256.h"
#include "sha256.h"


#define HEADER_LEN 4
#define ERRO_REASON_LEN 40
#define MAX_CLIENTS 100

typedef struct work{
	uint32_t difficulty;
	BYTE *seed;
	uint64_t start;
	uint8_t worker_count;
	BYTE *target;
	int client_fd;
	struct work *next;
	char *str_difficulty;
	char *str_seed;
	char *str_start;
} work_msg_t;

char *create_response_msg(char *curr_msg, char *add, int *size); 
char *read_message(char *msg, work_msg_t **worker_queue, int i);
int process_solution(char *msg);
BYTE *convert_to_binary(uint32_t num);
BYTE *map_difficulty(uint32_t difficulty);
uint32_t two_power_of(int num); // might not need this either!!!
BYTE *convert_to_hex(BYTE *binary_num); // probs don't need this at all!!!!
BYTE *convert_to_hex2(uint32_t num);
char *convert_to_hex3(uint64_t num);
BYTE *get_seed(char *token);
BYTE *concatenate(BYTE *seed, uint64_t solution);
BYTE *get_solution(uint64_t solution);
void remove_work(work_msg_t **worker_queue, int client_fd);
//uint32_t ntohl(uint32_t netlong);


void parse_work(work_msg_t **worker_queue, char *msg, int i);
int process_work(work_msg_t *work);

#endif============================================
src/server.c
22:57:27_Wednesday_24_May_2017
============================================
/* A simple server in the internet domain using TCP
The port number is passed as an argument 

An Extended version of the server program provided, using select() 
to handle concurrent clients
https://www.gnu.org/software/libc/manual/html_node/Server-Example.html
 To compile: gcc server.c -o server 
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/time.h>
#include <pthread.h>
#include "protocol_messages.h"
void *increment_start(void *num);


int main(int argc, char **argv)
{
	int sockfd, newsockfd, portno, clilen;
	char buffer[256];
	char *msg;
	int msg_size = 100;

	time_t t;

	

	int select_return = 0;
	struct timeval select_timer;

	select_timer.tv_sec = 0;
	select_timer.tv_usec = 2000;

	// make a worker queue (LL style)
	work_msg_t **worker_queue = malloc(sizeof(work_msg_t));
	*worker_queue = NULL;

	pthread_t thread1;
	int more;
	int count = 0;
	char read_buffer[1];
	char more_buffer[2];
	int size = 100;

	fd_set read_fds;
	fd_set all_fds;
	int num_fds;
	int yes = 1;
	
	FILE *fp = fopen("log.txt", "w");
	

	FD_ZERO(&read_fds);
	FD_ZERO(&all_fds);


	struct sockaddr_in serv_addr, cli_addr;
	int n;
	int i;

	if (argc < 2) 
	{
		fprintf(stderr,"ERROR, no port provided\n");
		exit(1);
	}

	 /* Create TCP socket */
	sockfd = socket(AF_INET, SOCK_STREAM, 0);

	if (sockfd < 0) 
	{
		perror("ERROR opening socket");
		exit(1);
	}

	
	num_fds = sockfd;
	FD_SET(sockfd, &all_fds);

	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));
	/* erases the data in the n bytes (second argument) of the memory
	starting at the location pointed to by s (first argument) 
	bzero(void *s, size_t n) */
	bzero((char *) &serv_addr, sizeof(serv_addr));

	portno = atoi(argv[1]);
	
	/* Create address we're going to listen on (given port number)
	 - converted to network byte order & any IP address for 
	 this machine */
	
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);  // store in machine-neutral format

	 /* Bind address to the socket */
	
	if (bind(sockfd, (struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0) {
		perror("ERROR on binding");
		exit(1);
	}
	
	/* Listen on socket - means we're ready to accept connections - 
	 incoming connection requests will be queued */
	
	/* 5 = defines the maximum length to which the queue of
       pending connections for sockfd may grow.*/
	listen(sockfd,5);
	

	clilen = sizeof(cli_addr);
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	/* Accept a connection - block until a connection is ready to
	 be accepted. Get back a new file descriptor to communicate on. */

	/* accept() used with connection-based socket types, extracts first
	connection request from queue of pening connections for the listening
	socket, sockfd, creates a new connected socket and returns a file descriptor 
	referring to that socket. NOTE: not in the listening state */

	while(1) {
		FD_ZERO(&read_fds);
		
		read_fds = all_fds;

		// iterate through worker queue here
		
		work_msg_t *tmp = *worker_queue;
		if(tmp != NULL) {
			if(pthread_create(&thread1, NULL, increment_start, (void *)&(tmp->start)) != 0) {
				printf("pthread error!");
				//exit(1);
			}
			if (pthread_join(thread1, NULL) != 0) {
				printf("pthread join error!");
				//exit(1);
			}
	
			if(process_work(tmp) == 1) {

				msg = create_response_msg(msg, "", &msg_size);
				msg = create_response_msg(msg, "SOLN ", &msg_size);
				msg = create_response_msg(msg, tmp->str_difficulty, &msg_size);
				msg = create_response_msg(msg, " ", &msg_size);
				msg = create_response_msg(msg, tmp->str_seed, &msg_size);
				msg = create_response_msg(msg, " ", &msg_size);
				msg = create_response_msg(msg, tmp->str_start, &msg_size);
				//printf("final_nonce = %s\n", tmp->str_start);
				msg = create_response_msg(msg, "\n", &msg_size);

				// printing to LOG FILE
				t = time(NULL); // get the time
				fprintf(fp, "%s",ctime(&t));
				fprintf(fp, "(%d) 0.0.0.0: --  %s\n\n", tmp->client_fd, msg);
				fflush(fp);

				n  = write(tmp->client_fd, msg, strlen(msg));
				if (n < 0) {
					perror("ERROR writing to socket");
					//exit(1);
				}
				// remove the node from the queue
				//worker_queue = tmp->next;
				//free(tmp);
				
				*worker_queue = tmp->next;

				tmp =  *worker_queue;
			}
			
		}
		select_return = select(num_fds+1, &read_fds, NULL, NULL, &select_timer);
		if(select_return < 0) {
			perror("ERROR on select");
			//exit(1);
		}
		else if(select_return > 0) {

			for(i=0; i <= num_fds; i++) {
				if(FD_ISSET(i, &read_fds)) {
			
					/* check if another client requests for connection  */
					if(i==sockfd) {
						newsockfd = accept(	sockfd, (struct sockaddr *) &cli_addr, (socklen_t *)&clilen);
					
						if (newsockfd < 0) {
							perror("ERROR on accept");
							//exit(1);
						}
						FD_SET(newsockfd, &all_fds);
		
						if(newsockfd > num_fds) {
							num_fds = newsockfd;
						}
					}
					else {
						more = 1;
						/* service an already-connected client socket that is ready
						for reading */
						// do the reading/writing
						bzero(buffer,256);
						bzero(read_buffer, 1);
						bzero(more_buffer, 2);

						char *response = (char *)malloc(sizeof(char)*size);
						response = create_response_msg(response, "", &size);

						while(more) {

							while(1) {
								n = read(i, read_buffer, 1);
								if(n<0) {
									perror("ERROR reading from socket");
								}
								if(n == 1) {
									if(read_buffer[0] == '\r') {
										buffer[count] = '\0';
										count ++;
										break;
									}
									buffer[count] = read_buffer[0];
									count++;
								}
								else {
									break;
								}
							}
							count = 0;
							// when the client disconnects
							if(n==0) {
								FD_CLR(i, &all_fds);
								more = 0;
								break;
							}

							// record in LOG FILE what is requested by client
							t = time(NULL); // get the time
							fprintf(fp, "%s",ctime(&t));
							fprintf(fp, "(%d) %" PRIu32": --  ", i, cli_addr.sin_addr.s_addr);
							fprintf(fp, "%s\r\n\n\n",buffer);
							

							msg = read_message(buffer, worker_queue, i);

							
							fflush(fp);
							response = create_response_msg(response, msg, &size);
							bzero(buffer, 256);

							n = read(i, more_buffer, 2);
							if(n == 2) {
								more = 1;
								buffer[count] = more_buffer[1];
								count++;
								bzero(more_buffer,2);

							}
							else if(n == 1) {
								// record in LOG FILE what is outputted by 0.0.0.0
								if(strcmp(response, "") != 0) {
									t = time(NULL); // get the time
									fprintf(fp, "%s",ctime(&t));
									fprintf(fp, "(%d) 0.0.0.0: --  %s\n\n", i, response);
									fflush(fp);
								}
								
								n = write(i, response, strlen(response));
								if(n<0) {
									perror("ERROR writing to socket");
									//exit(1);
								}
								break;
							}
						}
						
					}
				}
			}
		}
		else {
			continue;
		}
		
	}
	// free the worker queue here if its not empty
	fclose(fp);
	/* close socket */
	close(sockfd);
	
	return 0; 
}

void *increment_start(void *num) {
	uint64_t *start = (uint64_t *)num;
//	printf("hello from the work function!!\n");
//	printf("start = %llu\n", *start);
	//printf("start + 1 = %llu\n", *start +1 );
	*start = *start + 1;
	return NULL;
}
============================================
src/Makefile
22:57:27_Wednesday_24_May_2017
============================================
# Author: Sampada Sakpal
# UserID: sakpals

## CC  = Compiler.
## CFLAGS = Compiler flags.
CC	= gcc
CFLAGS = -Wall -g -Wextra  -std=gnu99


## OBJ = Object files.
## SRC = Source files.
## EXE = Executable name.

SRC =		protocol_messages.c sha256.c server.c 
OBJ =		protocol_messages.o sha256.o server.o 
EXE = 		server

## Top level target is executable.
$(EXE):	$(OBJ)
		$(CC) $(CFLAGS) -o $(EXE) $(SRC) -pthread


## Clean: Remove object files and core dump files.
clean:
		/bin/rm $(OBJ)


## Clobber: Performs Clean and removes executable file.

clobber: clean
		/bin/rm $(EXE)
